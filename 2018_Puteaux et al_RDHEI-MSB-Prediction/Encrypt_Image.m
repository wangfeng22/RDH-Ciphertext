function [encrypt_I] = Encrypt_Image(origin_I,K_e)
% 函数说明：对图像origin_I进行bit级异或加密
% 输入：origin_I（原始图像）,,K_e（图像加密密钥）,error_location_map（MSB错误预测位置图）
% 输出：encrypt_I（加密图像）

[row,col] = size(origin_I); %计算origin_I的行列值
encrypt_I = origin_I;  %构建存储加密图像的容器
%% 根据密钥生成与origin_I大小相同的随机矩阵
rand('seed',K_e); %设置种子
E = round(rand(row,col)*255); %随机生成row*col矩阵
%% 根据E对图像origin_I进行bit级加密
for i=1:row
    for j=1:col
        encrypt_I(i,j) = bitxor(origin_I(i,j),E(i,j));
    end
end
%% 为了简化代码，这里没有将error_location_map嵌入到加密图像中，而是之间默认双方共知标记图。
%% 将error_location_map嵌入到加密图像中
% marked_I = encrypt_I;
% 注意：MSB错误预测位置图需要嵌入到加密图像的MSB中，并且要以8个像素为一个分块来嵌入；
%      若当前分块8个像素的map至少有一个标记为1，则该分块map嵌入之后，要选择该分块前后的map全为0的无错分块，并将这两个无错分块的MSB全设为1，作为错误分块的标记块，方便后续的数据提取；
%      若有连续的错误分块，则将连续的错误分块当做一个整体，再将其前后的两个无错分块的MSB全设为1，作为标记；
%      错误块和标记块都不能用来嵌入秘密信息。
% 设置标记块的目的：因为MSB要用来嵌入随机的0/1值，若不设置标记块，在数据嵌入之后，就无法区分MSB为1的像素，是嵌入了信息的载密像素，还是预测错误的像素，最终导致提取数据错误。
%
% error_location_map的提取：在嵌入秘密信息之后，以8个像素为一个单位进行判断
% 若8个MSB不是全为1（表示嵌入的8位随机的0/1秘密信息），则这8个像素的map都为0，即都是无预测错误像素；
% 若8个MSB全为1，则这8个像素的map也都为0（因为全为1的是标记块，标记块都是无错块）；
% 两个全为1的分块(标记块)之间的分块，其每个像素的MSB就是该像素的map。
%
% 例子: error_location_map： 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 1 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 （8个像素为一个分块） 
%       添加标记块之后的map： 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 1 1 1 1 1 1 1 1 | 0 0 1 0 0 0 0 0 | 1 1 1 1 1 1 1 1 | 0 0 0 0 0 0 0 0 （最终嵌入到加密图像中的状态） 
%                             可嵌入块-----------可嵌入块-----------标记块-------------错误块--------------标记块-----------可嵌入块
%       嵌入信息之后的MSB值: 0 0 1 0 1 0 1 1 | 0 1 1 0 1 0 1 0 | 1 1 1 1 1 1 1 1 | 0 0 1 0 0 0 0 0 | 1 1 1 1 1 1 1 1 | 0 1 1 0 1 0 1 0
%                             嵌入信息-----------嵌入信息-------------不变---------------不变---------------不变-----------嵌入信息
%                           不全为1，无错块-----不全为1，无错块-----全为1，无错块----标记块之间的分块-----全为1，无错块-----不全为1，无错块
%                              map全为0-----------map全为0-----------map全为0--------错误块（不变）--------map全为0-----------map全为0
%   提取error_location_map: 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 1 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0                                             
%
end