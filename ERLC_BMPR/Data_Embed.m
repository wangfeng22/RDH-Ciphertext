function [stego_I,emD] = Data_Embed(ES_I,K_sh,K_hide,D)
% 函数说明：在加密混洗图像ES_I中嵌入秘密信息
% 输入：ES_I（加密混洗图像）,K_sh（图像混洗密钥）,K_hide（数据嵌入密钥）,D（待嵌入的秘密信息）
% 输出：stego_I（载密图像）,emD(嵌入的秘密信息)

[row,col] = size(ES_I); %计算ES_I的行列值
%% 根据图像混洗密钥K_sh恢复图像像素的原始位置
rand('seed',K_sh); %设置种子
SH = randperm(row*col); %生成大小为row*col的伪随机序列
[reshuffle_I] = Image_ReShuffle(ES_I,SH);
%% 从图像LSB中提取可嵌入空间的大小信息
num = ceil(log2(row))+ceil(log2(col))+2; %记录空出空间大小需要的比特数（+2代表最大嵌入率不超过4bpp）
room_bits = zeros(1,num); %记录空间大小的比特流
for i=1:num
    value = reshuffle_I(1,i);
    bit = mod(value,2);
    room_bits(i) = bit;
end
[room] = BinaryConversion_2_10(room_bits); %空间大小
%% 根据数据嵌入密钥K_hide对原始秘密信息D进行加密
[encrypt_D] = Data_Encrypt(D,K_hide);
%% 在空出的空间中嵌入秘密信息
marked_I = reshuffle_I;
num_emD = 0; %计数，嵌入秘密信息数
num_D = length(D);
for pl=1:3
    if num_emD==num_D || num_emD==room %秘密信息已嵌完||已达到最大嵌入量
        break;
    end
    index = 8-pl+1; %像素第pl个位平面的索引
    for i=1:row
        for j=1:col
            if num_emD==num_D || num_emD==room %秘密信息已嵌完||已达到最大嵌入量
                break;
            end
            value = marked_I(i,j); %当前像素值
            [bin2_8] = BinaryConversion_10_2(value); %转换成8位二进制
            num_emD = num_emD+1;
            bin2_8(index) = encrypt_D(num_emD);
            [value] = BinaryConversion_2_10(bin2_8);
            marked_I(i,j) = value; %含有秘密信息的像素值
        end
    end
end
%% 将含有秘密信息的标记图像marked_I进行混洗
rand('seed',K_sh); %设置种子
SH = randperm(row*col); %生成大小为row*col的伪随机序列
[stego_I] = Image_Shuffle(marked_I,SH);
%% 统计嵌入的秘密信息
emD = D(1:num_emD);
end